1. Какова разница между абстрактным классом и интерфейсом?

Абстрактный класс - класс, снабженный словом abstract, его отличие от неабстрактного класса в том, 
что невозможно создать экземпляр такого класса, можно отнаследоваться от абстрактного класса. Абстрактный класс может содержать
поля, методы с реализацией и абстрактные методы без реализации, которые обязаны быть реализованы в классе-наследнике.

Интерфейс - это специальный тип класса, который не может содержать реализации методов, а только лишь их объявление(если не говорить о java8, 
в которой есть возможность добавить реализацию по умолчанию для методов интерфейса). Реализованы они
должны быть в классе, который имплементирует(реализует) интерфейс. В объявлении класса, реализующего интерфейс, должно быть ключевое слово 
implemented SomeInterface.

В отличие от наследования от абстрактного класса, реалицация может быть от нескольких интерфейсов, что похоже на множественное наследование,
которого, как такового, в языке java нет.
В отличие от интерфейса, абстрактный класс может содержать реализацию методов.


2. Как «насильно» вызвать сборку мусора?
Сборщик мусора - garbage collector - составная часть виртуальной java-машины, встроенный инструмент для высвобождения памяти. В отличие от
С++, управление памятью в java происходит автоматически, деструкторы объектов вызывать не нужно, они отсутствуют в принципе. GC освобождает
память, занимаемую объектами, на которые не указывает ни одна ссылка, автоматически, а в какой момент времени, неизвестно, это регламентируется
внутренней логикой jvm. Можно попросить виртуальную java-машину вызвать сборщик мусора, вызвав метод System.gc(); однако, нельзя быть уверенным в 
том, когда он будет вызван, и очистится ли память, занимаемая интересующим нас объектом.
Есть разные режимы работы сборщика мусора, которые по-разному работают с объектами разных поколений, это можно настроить в параметрах java-машины.


3. Когда требуется явное приведение классов?
Приведение классов - процесс преобразования объекта, принадлежащего одному классу, к объекту другого класса. 
Бывает явное и неявное приведение, 
Явное приведение классов требуется, когда нам необходимо привести объект родительского класса к объекту дочернего класс, это также называется
нисходящим приведением.
При восходящем приведении, когда мы преобразуем объект дочернего класса к объекту родителя, явное приведение не требуется.


4. Чем конструкторы отличаются от других методов?
Конструкторы - особые методы, название которых совпадает с названием класса, и вызываются они только при инициализации объекта данного класса 
при помощи ключевого слова new и названия класса. Конструкторы не имеют возвращаемого значения, но, фактически, они возвращают ссылку на 
только что созданный объект. Конструкторы могут быть:
 - "по умолчанию" - если явно не определен ни один конструктор, при вызове new SomeClass() создается виртуальной машиной, т.е. любой 
 класс по умолчанию имеет свой конструктор.
  - "без параметров"
  - "с параметрами"
Из дочернего класса может быть вызван конструктор ближайшего родителя, используя super.
При вызове собственного конструктора дочернего класса вызывается вся цепочка конструкторов суперклассов сверху вниз, начиная от конструктора 
класса Object.


5. Можно ли вызывать конструкторы один из другого, если их в классе несколько?
Да, можно, при этом используется ключевое слово this. Например, вызов из конструктора без параметров конструктора с параметрами - 
 this.MyClass(param1, ... paramN);
Ключевое слово this указывает на текущий объект этого класса.


6. В чем разница между JDK и JRE?
JRE - java runtime environment - среда выполнения java, содержащая java-машину и набор стандартных библиотек для исполнения java-программ, 
представленных в виде java-классов. 
JDK - java development kit - содержит то же, что JRE, 
+ компилятор, позволяющий компилировать исходные коды *.java в классы *.class;
+ исходные коды стандартных библиотек
+ некоторые примеры
+ javadoc - инструмент создания автоматической документации в комментариях классам, методам и т.д., используя специальные аннотации,
такие, как @return, @param, @autor и др, это отдельная тема.
+ архиватор jar (java archiver) - позволяет работать соответственно с *.jar.
+ appletviewer - средство для запуска апплетов(сейчас практически не используется, устаревшая технология)


7. Имеет ли значение в каком порядке перехватывать исключения FileNotFoundException и IOExceptipon?
Да, имеет.
Для начала надо сказать, что все exceptions - пример обрабатываемых исключительных ситуаций, в отличие от errors(например RuntimeError).
Есть также и необрабатываемые exceptions, например, NullPointerException.
Все эксепшены наследуются от класса Exception, причем FileNotFoundException наследуется от IOExceptipon, соответственно, первым должен быть 
перехвачен именно FileNotFoundException, т.к. иначе этот код никогда не сработает, и будет обработан более общим IOExceptipon с потерей конкретики.


8. Могут ли внутренние классы, описанные внутри метода, иметь доступ к локальным переменным этого метода?
Внутренние классы, описанные внутри метода - это т.н. локальные классы, они имеют доступ к локальным полям обрамляющего класса, которые не 
помечены, как final, а вот сами эти классы видны только внутри блока(метод, блок инициализации), где они описаны.
Изнутри такого внутреннего класса нельзя использовать локальные переменные метода(или блока инициализации), в котором описан.
Внутренние классы не могут быть private, public, protected static - объявляются просто class MyInnerClass{}


9. Как подкласс может обратиться к методу или конструктору из суперкласса?
Подкласс - дочерний класс, суперкласс - родительский класс.
Обратиться можно с помощью super - также описано в ответе на вопрос 4.


10. В чем разница между очередью и стеком?
Очередь и стек - суть структуры хранения данных, состоящие из элементов, называемых nodes - узлы.
В очереди и стеке используются разные принципы доступа к элементам.
Для стека - это LIFO - last in - first out;
для очереди - FIFO - first in - first out.
Это значит, что, положив объект в стек(метод push), он помещается на вершину стека, и метод извлечения из стека(pop) вернет нам его, затем 
предыдущий, и так до самого старого. Принцип стопки книг. Пример - стек вызова.
Очередь - принцип обычной очереди: встал в хвост последним - значит и извлечен будешь последним(если мы не говорим о двуглавой очереди).


11. Что вам приходит в голову, когда вы слышите о новом поколении (young generation) в Java?
В голову приходит сборщик мусора, в котором young generation - это пул молодых объектов, т.е. объектов, которые созданы недавно,
либо к ним недавно были обращения.
Частично про это было написано в ответе на вопрос 2.
Во время работы сборщика мусора объекты перемещаются из одного пула в другой, в соответствие в логикой для конкретной реализации сборщика мусора.


12. Есть два класса: A и B. Класс B должен информировать класс A когда случается некое важное событие. Какой design-pattern вы должны реализовать?
Паттерн Observer - наблюдатель. Используются Listeners.


13. Какой модификатор доступа надо указать в классе, чтобы доступ к нему имели только классы из того же пакета?
Применяется модификатор доступа package, который используется по умолчанию, и его указывать не обязательно.


14. Чем отличается статический внутренний класс от просто внутреннего класса?
Статический внутренний класс описан внутри другого класса, как static, является членом обрамляющего класса и не связан с его экземплярами. 
Нестатический вложенный класс, в отличие от статического, является членом экземпляра обрамляющего класса, и поэтому создавать экземпляры такого вложенного 
класса можно только из нестатических методов обрамляющего класса.
Статический вложенный класс имеет доступ к статическим полям и методам обрамляющего класса, 
все методы (и статические и нет) обрамляющего класса имеют доступ к членам вложенного класса.


15. можно ли обратиться к не-статической переменной из статического метода?
Статический метод принадлежит классу, а не экземпляру класса, а нестатическая переменная принадлежит экземпляру класса.
Обратиться к такой переменной поэтому нельзя, будет ошибка компиляции.


16. какие типы данных есть в Java?
Типы данных делятся на 2 типа: ссылочные и примитивные.
Примитивные: boolean, char, byte, short, int, float, long, double
Ссылочные - это классы, интерфейсы, массивы, String.


17. Чем отличаются переопределение (Override) и перегрузка (Overload)
Переопределение - описание родительского метода в классе-потомке с аннотацией(или без нее, используется для наглядности и читабельности кода) @Override.
Перегрузка - использование разных сигнатур методов с одинаковым названием, но разным количеством или типом параметров.


18. Что такое итератор?
Итератор - это объект коллекции, который позволяет перебрать все ее элементы с помощью метода next().
получить его можно, вызвав метод myCollection.iterator(); 
Метод есть в любой коллекции Collection, реализующей интерфейс Iterable.

19. Перечислите основные категории исключительных ситуаций
Бывают обрабатываемые и необрабатываемые исключительные ситуации.
Обрабатываемые - Exceptions(кроме NullPointerException) ,
Необрабатываемые - Errors(например, RunTimeError)


20. Какая разница между throw и throws?
throw используется для вызова исключительной ситуации,
throws в описании метода указывает на тот факт, что метод может выбросить данное исключение, и его нужно будет обработать на верхнем уровне.


21. Зачем нужен блок finally?
Этот блок используется при обработке исключительных ситуаций в конструкции try{}catch(){}finally{},
и в этом блоке располагается код, который будет выполнен в любом случае, будет ли выброшено исключение, или нет.
Если даже исключение будет выброшено, этот код сработает после блока catch(){}


22. Что такое finalize?
Это метод, вызываемый сборщиком мусора для объекта, ссылок на который уже не осталось, удаляет такой объект из памяти.
Его можно переопределить, в таком случае нужно в конце переопределенного метода взвать super.finalize(). 
В принципе этот метод использовать не рекомендуется, т.к. это не гарантирует очистку памяти сборщиком мусора именно сейчас,
 лучше высвобождать ресурсы самому(закрывать соединения и т.д.).
 

23. Перечислите все виды внутренних классов
Внутренние классы полностью определены внутри другого класса.
1. Статические - имеют доступ только к статическим полям внешнего класса(т.к. не относятся к экземпляру). Сами могут содержать статические поля и методы.
2. Нестатические - имеют доступ к полям внешнего класса, относятся к экземпляру класса.
3. Локальные - определены внутри метода внешнего класса.
4. Анонимные классы - определены внутри метода внешнего класса, нет имеют имени, не могут быть статическими и используются прямо при обЪявлении.





  